# -*- coding: utf-8 -*-
"""Untitled6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uq4HHQyLma5MNCVtFUpwr6g08qGohWrp
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np

import matplotlib.pyplot as plt
import seaborn as sns
sns.set_style('whitegrid')
plt.style.use("fivethirtyeight")
# %matplotlib inline

# For reading stock data from yahoo
from pandas_datareader.data import DataReader
import yfinance as yf
from pandas_datareader import data as pdr



# For time stamps
from datetime import datetime


# The tech stocks we'll use for this analysis
tech_list = ['AAPL', 'GOOG', 'MSFT', 'AMZN']

# Set up End and Start times for data grab
tech_list = ['AAPL', 'GOOG', 'MSFT', 'AMZN']

end = datetime.now()
start = datetime(end.year - 1, end.month, end.day)

for stock in tech_list:
    globals()[stock] = yf.download(stock, start, end)


company_list = [AAPL, GOOG, MSFT, AMZN]
company_name = ["APPLE", "GOOGLE", "MICROSOFT", "AMAZON"]

for company, com_name in zip(company_list, company_name):
    company["company_name"] = com_name

df = pd.concat(company_list, axis=0)
df.tail(10)



AAPL.info()

AAPL.describe()

plt.figure(figsize=(15, 10))
plt.subplots_adjust(top=1.25, bottom=1.2)

for i, company in enumerate(company_list, 1):
    plt.subplot(2, 2, i)
    # Check if 'Adj Close' exists, if not try 'Close'
    if 'Adj Close' in company.columns:
        company['Adj Close'].plot()
    else:
        company['Close'].plot()
    plt.ylabel('Adj Close')
    plt.xlabel(None)
    plt.title(f"Closing Price of {tech_list[i - 1]}")

plt.tight_layout()

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import yfinance as yf
from datetime import datetime

# Set up the tech stocks we'll use for this analysis
tech_list = ['AAPL', 'GOOG', 'MSFT', 'AMZN']

# Set up End and Start times for data grab
end = datetime.now()
start = datetime(end.year - 1, end.month, end.day)

# Download stock data
company_list = []
for stock in tech_list:
    data = yf.download(stock, start, end)
    data['company_name'] = stock  # Add a column for the company name
    company_list.append(data)

# Calculate Daily Returns
for company in company_list:
    # Check if 'Adj Close' exists, if not try 'Close'
    close_col = 'Adj Close' if 'Adj Close' in company.columns else 'Close'
    company['Daily Return'] = company[close_col].pct_change()

# Debugging: Print the columns of each DataFrame to check for 'Daily Return'
for i, company in enumerate(company_list):
    print(f"{tech_list[i]} DataFrame columns: {company.columns}")


# Plotting the Daily Returns
fig, axes = plt.subplots(nrows=2, ncols=2, figsize=(15, 10))
fig.set_figheight(10)
fig.set_figwidth(15)

# Plot for each company
AAPL = company_list[0]
GOOG = company_list[1]
MSFT = company_list[2]
AMZN = company_list[3]

# Apple Daily Return Plot
AAPL['Daily Return'].plot(ax=axes[0, 0], legend=True, linestyle='--', marker='o', color='blue')
axes[0, 0].set_title('APPLE')
axes[0, 0].set_ylabel('Daily Return')

# Google Daily Return Plot
GOOG['Daily Return'].plot(ax=axes[0, 1], legend=True, linestyle='--', marker='o', color='orange')
axes[0, 1].set_title('GOOGLE')
axes[0, 1].set_ylabel('Daily Return')

# Microsoft Daily Return Plot
MSFT['Daily Return'].plot(ax=axes[1, 0], legend=True, linestyle='--', marker='o', color='green')
axes[1, 0].set_title('MICROSOFT')
axes[1, 0].set_ylabel('Daily Return')

# Amazon Daily Return Plot
AMZN['Daily Return'].plot(ax=axes[1, 1], legend=True, linestyle='--', marker='o', color='red')
axes[1, 1].set_title('AMAZON')
axes[1, 1].set_ylabel('Daily Return')

# Adjust layout
fig.tight_layout()
plt.show()

plt.figure(figsize=(12, 9))

for i, company in enumerate(company_list, 1):
    plt.subplot(2, 2, i)
    company['Daily Return'].hist(bins=50)
    plt.xlabel('Daily Return')
    plt.ylabel('Counts')
    plt.title(f'{company_name[i - 1]}')

plt.tight_layout()

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import yfinance as yf
from datetime import datetime

# Set up the tech stocks we'll use for this analysis
tech_list = ['AAPL', 'GOOG', 'MSFT', 'AMZN']

# Set up End and Start times for data grab
end = datetime.now()
start = datetime(end.year - 1, end.month, end.day)

# Download adjusted closing prices for the tech stocks
closing_df = yf.download(tech_list, start=start, end=end)

# Check the structure of the downloaded DataFrame
print(closing_df.head())  # Print the first few rows to see the available columns

# Use 'Adj Close' if available, otherwise use 'Close'
if 'Adj Close' in closing_df.columns:
    closing_df = closing_df['Adj Close']
else:
    closing_df = closing_df['Close']

# Make a new tech returns DataFrame
tech_rets = closing_df.pct_change()

# Display the first few rows of the returns DataFrame
print(tech_rets.head())

sns.jointplot(x='GOOG', y='GOOG', data=tech_rets, kind='scatter', color='seagreen')

sns.jointplot(x='GOOG', y='MSFT', data=tech_rets, kind='scatter')

sns.pairplot(tech_rets, kind='reg')

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import yfinance as yf
from datetime import datetime
import seaborn as sns

# Set up the tech stocks we'll use for this analysis
tech_list = ['AAPL', 'GOOG', 'MSFT', 'AMZN']

# Set up End and Start times for data grab
end = datetime.now()
start = datetime(end.year - 1, end.month, end.day)

# Download adjusted closing prices for the tech stocks
closing_df = yf.download(tech_list, start=start, end=end)

# Use 'Adj Close' if available, otherwise use 'Close'
if 'Adj Close' in closing_df.columns:
    closing_df = closing_df['Adj Close']
else:
    closing_df = closing_df['Close']

# Make a new tech returns DataFrame
tech_rets = closing_df.pct_change()

# Drop NaN values from the returns DataFrame
tech_rets = tech_rets.dropna()

# Set up our figure by naming it returns_fig, call PairGrid on the DataFrame
return_fig = sns.PairGrid(tech_rets)

# Using map_upper we can specify what the upper triangle will look like.
return_fig.map_upper(plt.scatter, color='purple')

# We can also define the lower triangle in the figure, including the plot type (kde)
# or the color map (BluePurple)
return_fig.map_lower(sns.kdeplot, cmap='cool_d')

# Finally, we'll define the diagonal as a series of histogram plots of the daily return
return_fig.map_diag(plt.hist, bins=30)

# Show the plot
plt.show()

plt.figure(figsize=(12, 10))

plt.subplot(2, 2, 1)
sns.heatmap(tech_rets.corr(), annot=True, cmap='summer')
plt.title('Correlation of stock return')

plt.subplot(2, 2, 2)
sns.heatmap(closing_df.corr(), annot=True, cmap='summer')
plt.title('Correlation of stock closing price')



rets = tech_rets.dropna()

area = np.pi * 20

plt.figure(figsize=(10, 8))
plt.scatter(rets.mean(), rets.std(), s=area)
plt.xlabel('Expected return')
plt.ylabel('Risk')

for label, x, y in zip(rets.columns, rets.mean(), rets.std()):
    plt.annotate(label, xy=(x, y), xytext=(50, 50), textcoords='offset points', ha='right', va='bottom',
                 arrowprops=dict(arrowstyle='-', color='blue', connectionstyle='arc3,rad=-0.3'))

plt.figure(figsize=(16,6))
plt.title('Close Price History')
plt.plot(df['Close'])
plt.xlabel('Date', fontsize=18)
plt.ylabel('Close Price USD ($)', fontsize=18)
plt.show()



import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import yfinance as yf
from sklearn.preprocessing import MinMaxScaler
from keras.models import Sequential
from keras.layers import Dense, LSTM, Dropout
from datetime import datetime

# Download historical stock price data
stock_symbol = 'AAPL'
start_date = '2012-01-01'
end_date = datetime.now()

# Fetch the data
data = yf.download(stock_symbol, start=start_date, end=end_date)

# Prepare the data
data = data[['Close']]  # Use only the 'Close' column
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data = scaler.fit_transform(data)

# Create the training and testing datasets
training_data_len = int(np.ceil(len(scaled_data) * 0.95))
train_data = scaled_data[0:training_data_len, :]

# Create the x_train and y_train datasets
x_train = []
y_train = []

for i in range(60, len(train_data)):
    x_train.append(train_data[i-60:i, 0])  # Previous 60 days
    y_train.append(train_data[i, 0])      # Current day

# Convert to numpy arrays
x_train, y_train = np.array(x_train), np.array(y_train)

# Reshape the data
x_train = np.reshape(x_train, (x_train.shape[0], x_train.shape[1], 1))

# Build the LSTM model
model = Sequential()
model.add(LSTM(50, return_sequences=True, input_shape=(x_train.shape[1], 1)))
model.add(Dropout(0.2))
model.add(LSTM(50, return_sequences=False))
model.add(Dropout(0.2))
model.add(Dense(25))
model.add(Dense(1))  # Output layer

# Compile the model
model.compile(optimizer='adam', loss='mean_squared_error')

# Train the model
model.fit(x_train, y_train, batch_size=1, epochs=1)

# Create the testing dataset
test_data = scaled_data[training_data_len - 60:, :]
x_test = []
y_test = data['Close'][training_data_len:].values  # Actual values for validation

for i in range(60, len(test_data)):
    x_test.append(test_data[i-60:i, 0])

# Convert to numpy array
x_test = np.array(x_test)

# Reshape the data
x_test = np.reshape(x_test, (x_test.shape[0], x_test.shape[1], 1))

# Get the predicted prices
predictions = model.predict(x_test)
predictions = scaler.inverse_transform(predictions)  # Inverse transform to get actual prices

# Create a new DataFrame for validation
valid = data[training_data_len:]
valid['Predictions'] = predictions  # Adding predictions to validation data

# Visualizing the data
plt.figure(figsize=(16, 6))
plt.title(f'{stock_symbol} Price Prediction', fontsize=24)
plt.xlabel('Date', fontsize=18)
plt.ylabel('Close Price USD ($)', fontsize=18)
plt.plot(data['Close'], label='Actual Price', color='blue')
plt.plot(valid['Predictions'], label='Predicted Price', color='orange')
plt.legend()
plt.show()

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import yfinance as yf
from sklearn.preprocessing import MinMaxScaler
from keras.models import Sequential
from keras.layers import Dense, LSTM, Dropout
from datetime import datetime

# Download historical stock price data for Google
stock_symbol = 'GOOGL'
start_date = '2012-01-01'
end_date = datetime.now()

# Fetch the data
data = yf.download(stock_symbol, start=start_date, end=end_date)

# Prepare the data
data = data[['Close']]  # Use only the 'Close' column
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data = scaler.fit_transform(data)

# Create the training and testing datasets
training_data_len = int(np.ceil(len(scaled_data) * 0.95))
train_data = scaled_data[0:training_data_len, :]

# Create the x_train and y_train datasets
x_train = []
y_train = []

for i in range(60, len(train_data)):
    x_train.append(train_data[i-60:i, 0])  # Previous 60 days
    y_train.append(train_data[i, 0])      # Current day

# Convert to numpy arrays
x_train, y_train = np.array(x_train), np.array(y_train)

# Reshape the data
x_train = np.reshape(x_train, (x_train.shape[0], x_train.shape[1], 1))

# Build the LSTM model
model = Sequential()
model.add(LSTM(50, return_sequences=True, input_shape=(x_train.shape[1], 1)))
model.add(Dropout(0.2))
model.add(LSTM(50, return_sequences=False))
model.add(Dropout(0.2))
model.add(Dense(25))
model.add(Dense(1))  # Output layer

# Compile the model
model.compile(optimizer='adam', loss='mean_squared_error')

# Train the model
model.fit(x_train, y_train, batch_size=1, epochs=1)

# Create the testing dataset
test_data = scaled_data[training_data_len - 60:, :]
x_test = []
y_test = data['Close'][training_data_len:].values  # Actual values for validation

for i in range(60, len(test_data)):
    x_test.append(test_data[i-60:i, 0])

# Convert to numpy array
x_test = np.array(x_test)

# Reshape the data
x_test = np.reshape(x_test, (x_test.shape[0], x_test.shape[1], 1))

# Get the predicted prices
predictions = model.predict(x_test)
predictions = scaler.inverse_transform(predictions)  # Inverse transform to get actual prices

# Create a new DataFrame for validation
valid = data[training_data_len:]
valid['Predictions'] = predictions  # Adding predictions to validation data

# Visualizing the data
plt.figure(figsize=(16, 6))
plt.title(f'{stock_symbol} Price Prediction', fontsize=24)
plt.xlabel('Date', fontsize=18)
plt.ylabel('Close Price USD ($)', fontsize=18)
plt.plot(data['Close'], label='Actual Price', color='blue')
plt.plot(valid['Predictions'], label='Predicted Price', color='orange')
plt.legend()
plt.show()

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import yfinance as yf
from sklearn.preprocessing import MinMaxScaler
from keras.models import Sequential
from keras.layers import Dense, LSTM, Dropout
from datetime import datetime

# Download historical stock price data for Microsoft
stock_symbol = 'MSFT'
start_date = '2012-01-01'
end_date = datetime.now()

# Fetch the data
data = yf.download(stock_symbol, start=start_date, end=end_date)

# Prepare the data
data = data[['Close']]  # Use only the 'Close' column
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data = scaler.fit_transform(data)

# Create the training and testing datasets
training_data_len = int(np.ceil(len(scaled_data) * 0.95))
train_data = scaled_data[0:training_data_len, :]

# Create the x_train and y_train datasets
x_train = []
y_train = []

for i in range(60, len(train_data)):
    x_train.append(train_data[i-60:i, 0])  # Previous 60 days
    y_train.append(train_data[i, 0])      # Current day

# Convert to numpy arrays
x_train, y_train = np.array(x_train), np.array(y_train)

# Reshape the data
x_train = np.reshape(x_train, (x_train.shape[0], x_train.shape[1], 1))

# Build the LSTM model
model = Sequential()
model.add(LSTM(50, return_sequences=True, input_shape=(x_train.shape[1], 1)))
model.add(Dropout(0.2))
model.add(LSTM(50, return_sequences=False))
model.add(Dropout(0.2))
model.add(Dense(25))
model.add(Dense(1))  # Output layer

# Compile the model
model.compile(optimizer='adam', loss='mean_squared_error')

# Train the model
model.fit(x_train, y_train, batch_size=1, epochs=1)

# Create the testing dataset
test_data = scaled_data[training_data_len - 60:, :]
x_test = []
y_test = data['Close'][training_data_len:].values  # Actual values for validation

for i in range(60, len(test_data)):
    x_test.append(test_data[i-60:i, 0])

# Convert to numpy array
x_test = np.array(x_test)

# Reshape the data
x_test = np.reshape(x_test, (x_test.shape[0], x_test.shape[1], 1))

# Get the predicted prices
predictions = model.predict(x_test)
predictions = scaler.inverse_transform(predictions)  # Inverse transform to get actual prices

# Create a new DataFrame for validation
valid = data[training_data_len:]
valid['Predictions'] = predictions  # Adding predictions to validation data

# Visualizing the data
plt.figure(figsize=(16, 6))
plt.title(f'{stock_symbol} Price Prediction', fontsize=24)
plt.xlabel('Date', fontsize=18)
plt.ylabel('Close Price USD ($)', fontsize=18)
plt.plot(data['Close'], label='Actual Price', color='blue')
plt.plot(valid['Predictions'], label='Predicted Price', color='orange')
plt.legend()
plt.show()